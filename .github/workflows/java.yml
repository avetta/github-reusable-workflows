# action.yml
name: 'Custom Github Action to Update Deployment YAML files'

on:
  workflow_call:
    inputs:
      image_tag:
        description: Image tag of the docker image
        required: true
        type: string
        default: 'latest'
      scala_version:
        description: Image tag of the docker image
        required: true
        type: string
        default: 'latest'  
      git_user:
        description: username to access github repo
        required: true
        type: string
      app_name:
        description: App name to be update
        required: true
        type: string
      environment:
        description: Environment to be update
        required: true
        type: string
      jenkins_user:
        description: Jenkins user
        required: true
        type: string
      DOCKER_TAG:
        description: Jenkins user
        required: true
        type: string
      GITHUB_COMMIT:
        description: Jenkins user
        required: true
        type: string
      GITHUB_BUILD_NUMBER:
        description: Jenkins user
        required: true
        type: string  
      embed_apm:
        description: Jenkins user
        required: false
        type: string    
        
    secrets:
      git_password:
        required: true
      jenkins_url:
        required: true  
      DOCKER_USERNAME:
        required: true
      DOCKER_PASSWORD:
        required: true
      jenkins_password:
        required: true
      JFROG_USERNAME:
        required: true
      JFROG_PASSWORD:
        required: true
      MONGODB_WD:
        required: true
      MONGODB_HOST:
        required: true  
      SCORINGSERVICE_MONGO_USER:
        required: true  
      SCORINGSERVICE_MONGO_PWD:
        required: true 
      SCORING_MONGO_AUTHENTICATION:
        required: true 
      INPUTCONFIGSERVICE_MONGO_USER:
        required: true 
      INPUTCONFIGSERVICE_MONGO_PWD:
        required: true 
      INPUTCONFIGSERVICE_MONGO_AUTHENTICATION:
        required: true 
      MONGODB_ARCHIVE:
        required: true  
        
jobs:
  build:
    name: Build and Test
    strategy:
      matrix:
        os: [ubuntu-18.04]
        java: [adopt@1.8]
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout current branch (full)
        uses: actions/checkout@v2
        with:
          fetch-depth: 0

      - name: Setup Java and Scala
        uses: olafurpg/setup-scala@v10
        with:
          java-version: ${{ matrix.java }}

      - name: Cache sbt
        uses: actions/cache@v2
        with:
          path: |
            ~/.sbt
            ~/.ivy2/cache
            ~/.coursier/cache/v1
            ~/.cache/coursier/v1
            ~/AppData/Local/Coursier/Cache/v1
            ~/Library/Caches/Coursier/v1
          key: ${{ runner.os }}-sbt-cache-v2-${{ hashFiles('**/*.sbt') }}-${{ hashFiles('project/build.properties') }}

      - name: Check that workflows are up to date 
        run: |
          export JFROG_USER=${{secrets.JFROG_USERNAME}}
          export JFROG_PASSWORD=${{secrets.JFROG_PASSWORD}}
          export JFROG_RO_USER=${{secrets.JFROG_USERNAME}}
          export JFROG_RO_PASSWORD=${{secrets.JFROG_PASSWORD}}
          sudo apt-get install -y mongodb-org
          wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-ubuntu1604-4.2.19.tgz
          ls -ltr
          tar -zxvf mongodb-linux-x86_64-ubuntu1604-4.2.19.tgz
          echo $PATH
          sudo apt-get install libcurl4
          sudo ln -s ${PWD}/mongodb-linux-x86_64-ubuntu1604-4.2.19/bin/mongod /usr/local/bin/mongod 
          mongod --version
          sudo ln -s ${PWD}/mongodb-linux-x86_64-ubuntu1604-4.2.19/bin/mongo /usr/local/bin/mongod 
          mongo --version
          #./mongodb-linux-x86_64-ubuntu1604-4.2.19/bin/mongod --version
          mkdir ${PWD}/mongodb-linux-x86_64-ubuntu1604-4.2.19/data
          ${PWD}/mongodb-linux-x86_64-ubuntu1604-4.2.19/bin/mongod --dbpath ${PWD}/${{secrets.MONGODB_WD}}/data --logpath ${PWD}/${{secrets.MONGODB_WD}}/mongodb.log --fork
          ${PWD}/mongodb-linux-x86_64-ubuntu1604-4.2.19/bin/mongo scoring --eval 'db.createUser({user:"${{secrets.INPUTCONFIGSERVICE_MONGO_USER}}",pwd:"${{secrets.INPUTCONFIGSERVICE_MONGO_PWD}}",roles:[{role:"readWrite",db:"scoring"}]});'
          ${PWD}/mongodb-linux-x86_64-ubuntu1604-4.2.19/bin/mongo input_config --eval 'db.createUser({user:"${{secrets.INPUTCONFIGSERVICE_MONGO_USER}}",pwd:"${{secrets.INPUTCONFIGSERVICE_MONGO_PWD}}",roles:[{role:"readWrite",db:"input_config"}]});'
          sbt ++${{inputs.scala_version}} clean coverage compile test
          sbt ++${{inputs.scala_version}} coverageReport
          sbt docker:stage
          #docker build -t pics/recalcservice ./target/docker/stage
          #docker images
          
     # - name: Report coverage to Codacy
      #  uses: codacy/codacy-coverage-reporter-action@0.2.1
       # with:
        #  project-token: ${{ secrets.CODACY_PROJECT_TOKEN }}

      - name: Login to DockerHub
        uses: docker/login-action@v1
        with:
          username: ${{secrets.DOCKER_USERNAME}}
          password: ${{secrets.DOCKER_PASSWORD}}
      - name: set version files
        id: setversion
        run: |
          # Check if $propertiesFile file exists. If not, create file
            export propertiesFile="./conf/serviceVersion.properties"
            if [ -f $propertiesFile ];
            then
              echo "File $propertiesFile exists."
            else
              echo "File $propertiesFile does not exist. Creating conf directory"
              mkdir ./conf
            fi
            # Update $propertiesFile
            echo "Writing commit ID and build # to conf files."
            echo "tag=${{inputs.DOCKER_TAG}}" | sudo tee -a $propertiesFile
            echo "commit=${{inputs.GITHUB_COMMIT}}" | sudo tee -a $propertiesFile
            echo "buildId=${{inputs.GITHUB_BUILD_NUMBER}}" | sudo tee -a $propertiesFile
            echo "Writing commit ID and build # to version.json file"
            echo \{\"buildId\":\"${{inputs.GITHUB_BUILD_NUMBER}}\",\"commit\":\"${{inputs.GITHUB_COMMIT}}\",\"tag\":\"${{inputs.DOCKER_TAG}}\"\} > ./version.json
            # Copy in file to conf directory for Play builds
            cp ./version.json ./conf/version.json
            # Output for verification purposes
            echo "Checking parameter values in $propertiesFile"
            echo "Parameters in $propertiesFile"
            cat $propertiesFile  
            echo ${{inputs.embed_apm}}
            echo '::set-output name=embed_apm::'${{inputs.embed_apm}}
            
      
        
      - name: Build image and push to DockerHub
        if: "${{ steps.setversion.outputs.embed_apm != 'true' &&  github.event_name != 'pull_request'}}"
        id: docker_build1
        uses: docker/build-push-action@v2
        with:
           # relative path to the place where source code with Dockerfile is located
          context: ./target/docker/stage
          push: true
           # Note: tags has to be all lower-case
          tags: pics/${{inputs.app_name}}:${{inputs.image_tag}}
          
      - name: Build image
        if: "${{ steps.setversion.outputs.embed_apm != 'false' &&  github.event_name != 'pull_request'}}"
        id: docker_build2
        uses: docker/build-push-action@v2
        with:
           # relative path to the place where source code with Dockerfile is located
          context: ./target/docker/stage
          push: false
           # Note: tags has to be all lower-case
          tags: pics/${{inputs.app_name}}:${{inputs.image_tag}}    
          
      
      - name: EmbedAPM        
        if: "${{ steps.setversion.outputs.embed_apm != 'false' &&  github.event_name != 'pull_request'}}"
        run: |
          curl https://download.newrelic.com/newrelic/java-agent/newrelic-agent/7.5.0/newrelic-java-7.5.0.zip --output newrelic-java-7.5.0.zip
          unzip newrelic-java-7.5.0.zip
          export Dockerfile="./Dockerfile"
          echo "FROM pics/${{inputs.app_name}}" | sudo tee -a $Dockerfile
          echo "ENV JAVA_OPTS="-javaagent:/opt/docker/lib/newrelic.jar"" | sudo tee -a $Dockerfile
          echo "ADD ./newrelic/newrelic.jar /opt/docker/lib/" | sudo tee -a $Dockerfile
          echo "ADD ./newrelic/newrelic.yml /opt/docker/lib/" | sudo tee -a $Dockerfile
          ls -ltr
      
      - name: Build image and push to DockerHub
        if: "${{ steps.setversion.outputs.embed_apm != 'false' &&  github.event_name != 'pull_request'}}"
        id: docker_build_push
        uses: docker/build-push-action@v2
        with:
           # relative path to the place where source code with Dockerfile is located
          context: .
          push: true
           # Note: tags has to be all lower-case
          tags: pics/${{inputs.app_name}}:${{inputs.image_tag}}
              
        
          

      - name: Trigger your-awesome-job-name job
        if: github.event_name != 'pull_request'
        run: |  
          environment=${{inputs.environment}}
          if [ -z $environment ]; then
            echo "Deployment configuration not found"
          else
            curl ${{secrets.jenkins_url}}/job/${{inputs.environment}}-deploy-generic/buildWithParameters \
             --user ${{inputs.jenkins_user}}:${{secrets.jenkins_password}} \
             --data ContainerName=${{inputs.app_name}} --data DockerHubTag=${{inputs.image_tag}}
          fi
